#ifndef WEBSERV_H
#define WEBSERV_H

#define READ_FROM_CLIENT 0
#define SEND_TO_CLIENT 1

#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <netinet/in.h> 
#include <fcntl.h>
#include <vector>
#include <algorithm>
#include <sys/types.h>
#include <map>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <dirent.h>
#define DEFAULT_CONFIG_PATH "config/default.conf"
#define WEBSERV "webserv v0.9"
/**********************************************************************
***********************************************************************
int socket(int family, int type, int protocol);

family - задает используемое семейство адресацию AF_INET для TCP/IP
type - задает тип взаимодействия; константа SOCK_STREAM соответствует
потоковому взаимодействию, SOCK_DGRAM - дейтаграмному.
Последний параметр - протокол, в нашем случае однозначно определяется
первыми двумя параметрами, поэтому можно указать NULL. IPPROTO_TCP - для
TCP и IPPROTO_UDP для UDP
Возвращает fd сокета и -1 в случае ошибки.
***********************************************************************
int bind(int sockfd, struckt sockaddr *addr, int addrlen);

Снабжает сокет адресом.
sockfd - дескриптор сокета, полученного в результате
вызова socket;
addr - указатель на структуру, содержащую адресс;
addrlen - размер структуры в байтах.
 Возвращает 0 в случае успеха, -1 в случае ошибки;
 Может вернуть ошибку при попытке использования привелигированного номера
порта [1; 1023]
struct sockaddr_in addr
{
	sin_family - обозначает семейство адресации (AF_INET)
	sin_port = порт в сетевом порядке битов htons(8080) - host to network short
	sin_addr - адрес, хранит s_addr, хранящую ip адрес в виде беззнакового
четырехбайтного целого в сетевом порядке байтов htonl(INADDR_ANY) host to
network long с маской 0.0.0.0, то есть с любым адресом машины
}

res = bind(sd, (struct sockaddr*)&addr, sizeof(addr));
if (res == -1){
	\\обработка ошибки
}
************************************************************************
int listen(int sd, int qlen) - перевод сокета в слушающий режим

sd - дескриптор сокета
qlen - размер очереди непринятых запросов на соединение. Обычно 5
***********************************************************************
int accept(int sd, struct sockaddr *addr, socklen_t *addrlen);

Принятие соединения
sd - дескриптор слушающего сокета
addr структура для записи адреса сокета, с которым установлено соединение
addrlen - указатель на тип, содержащий размер addr структуры
 Возвращает новый дескриптор сокета, созданного для обслуживания вновь
установленного соединения. -1 в случае ошибки
***********************************************************************
int setsokopt(int sd, int level, int optname, const void *optval, int optlen);
Применение опции к сокету
sd - дескриптор
level - уровень стека протоколов

Во избежание "залипания сокета":
int opt = 1;
setsockopt(ls, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
************************************************************************
Перевод сокета в неблокирующий режим:

flags = fcntl(sd, F_GETFL);
fcntl(sd, F_SETFL, flags | O_NONBLOCK);
************************************************************************
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exfds,
	struct timeval *timeout);

Обработка событий
fd_set - множества дескрипторовб для возможности немедленного чтения, записи и
наличие исключительной ситуации.
n - количество значащих элементов в этих множествах. Этот параметр можно установить
равным max_d+1, где max_d - максимальный номер декриптора среди подлежащих обработке
timeout - задает промежуток времени, спустя который следует вернуть управление,
даже если никаких событий связанных с дескрипторами не произошло

для работы с fd_set
FD_ZERO(fd_set *set) очистить множество
FD_CLR(int fd, fd_set *set) убрать дескриптор из мн-ва
FD_SET(int fd, fd_set *set) добавить дескриптор к мн-ву
FD_ISSET(int fd, fd_set *set) входит ли дексриптор в мн-во?

***********************************************************************
Основной цикл:

					socket()
					   |
					fcntl()
					   |
					bind()
					   |
					listen()
					   |
					FD_ZERO()
					FD_SET()
					   |
					select()<-----------------------------------------<
	    timeout   /    |                                              |
				/	FD_ISSET()                                        |
		close()        |       \                                      |
		|      listening socket \ активное подключение                |
		|              |         recv()---отправляем данные клиенту   |
		|          accept()        | eof    \                         |
		|               |        close()     \                        |
		|               |        FD_CLR()   send()                    |
		|               |           |         |                       |
		|          FD_SET()->------------------------------------------
		|               
	   /
	break завершение программы;
***********************************************************************
HTTP REQUEST

Цель запроса, обычно URL, или абсолютный путь протокола, порт и
домен обычно характеризуются контекстом запроса.
Формат цели запроса зависит от используемого HTTP-метода. Это может быть
Абсолютный путь, за которым следует '?' и строка запроса. Это самая распространённая форма,
называемая исходной формой (origin form) . Используется с методами GET, POST, HEAD, и OPTIONS.

POST / HTTP 1.1
GET /background.png HTTP/1.0
HEAD /test.html?query=alibaba HTTP/1.1
OPTIONS /anypage.html HTTP/1.0

Полный URL - абсолютная форма (absolute form) , обычно используется с GET при подключении к прокси.
GET http://developer.mozilla.org/ru/docs/Web/HTTP/Messages HTTP/1.1

Компонента URL "authority", состоящая из имени домена и (необязательно) порта (предваряемого символом ':'),
называется authority form. Используется только с методом CONNECT при установке туннеля HTTP.
CONNECT developer.mozilla.org:80 HTTP/1.1
Форма звёздочки (asterisk form), просто "звёздочка" ('*') используется с методом OPTIONS и представляет сервер.
OPTIONS * HTTP/1.1

GET, HEAD, DELETE, OPTIONS обычно не нуждаются в теле запроса,
однако POST запрос как правило содержит (данные HTML-форм).

Тела можно разделить на две категории:

-Одноресурсные тела, состоящие из одного отдельного файла, определяемого двумя
заголовками: Content-Type и Content-Length.

-Многресурсные тела, состоящие из множества частей, каждая из которых сожержит свой
бит информации. Они обычно связанны с HTML-формами.
***********************************************************************
***********************************************************************
HTTP RESPONSE

Стартовая строка ответа - строка состояния и содержит:
1) Версию протокола, обычно HTTP/1.1
2) Код состояния, показывающая, был ли запрос успешным. Примеры: 200, 404 , 302
3) Пояснение (status text). Краткое текстовое описание кода состояния, помогающее
пользователю понять сообщение  HTTP.
Пример строки статуса:
HTTP/1.1 404 Not Found.

HEAD

Заголовки ответов имеют ту же структуру, что и все остальные заголовки:
не зависящая от регистра строка, завершаемая двоеточием и значение, структура которого
определяется типом заголовка.
Весь заголовок, включая значение, представляет собой одну строку.

Существует множество заголовков ответов. Их можно разделить на несколько групп:

- Основные заголовковки, например, Via(en-US), относящиеся к сообщению в целом.
- Заголовки ответа, например, Vary  и  Accept-Ranges, сообщающие дополнительную
информацию о сервере, которая не уместилась в строку состояния.
- Заголовки сущности, например, Cintent-Length, относящиеся к телу ответа.
Отсутствуют, если у запроса нет тела.

BODY

Есть не у всех ответов: у ответов с кодом состояния. например, 201 или 204,
оно обычно отсутствует.
Тела можно разделить на три категории:
- Одноресурсные тела (Singke-resource bodies), состоящие из отлельного файла известной длины,
определяемые двумя заголовками: Content-Type и Content-Length.
- Одноресурсные тела (Single-resource bodies) , состоящие из отдельного файла неизвестной
длины, разбитого на небольше части (chunks) с заголовком Transfer-Encoding(en-Us),
значением котогого является chunked.
- Многоресурсные тела (Multiple-resource bodies), состоящие из многокопонентного тела,
каждая часть котогого содержит свой сегмент информации. Они относительно редки.

***********************************************************************
Примеры ответов:

HTTP/1.1 405 Method Not Allowed
Allow: GET
Content-Length: 0
Content-Location: /
Content-Type: text/plain
Date: Sat, 18 Dec 2021 12:42:11 GMT
Last-Modified: Fri, 10 Sep 2021 07:00:17 GMT
Server: Weebserv/1.0.0 (Unix)
Transfer-Encoding: identity

HTTP/1.1 404 Not Found
Content-Length: 189
Content-Location: /oulalala
Content-Type: text/html
Date: Sat, 18 Dec 2021 12:42:11 GMT
Server: Weebserv/1.0.0 (Unix)
Transfer-Encoding: identity

HTTP/1.1 200 OK
Content-Length: 30
Content-Location: /index.html
Content-Type: text/html
Date: Sat, 18 Dec 2021 12:42:11 GMT
Last-Modified: Tue, 14 Dec 2021 04:44:22 GMT
Server: Weebserv/1.0.0 (Unix)
Transfer-Encoding: identity

HTTP/1.1 403 Forbidden
Content-Length: 202
Content-Location: /file_should_exist_after
Content-Type: text/html
Date: Sat, 18 Dec 2021 12:42:11 GMT
Server: Weebserv/1.0.0 (Unix)
Transfer-Encoding: identity

HTTP/1.0 400 Bad Request
Content-Type: text/html; charset=UTF-8
Referrer-Policy: no-referrer
Content-Length: 1555
Date: Sat, 18 Dec 2021 13:19:43 GMT

HTTP/1.0 411 Length Required
Content-Type: text/html; charset=UTF-8
Referrer-Policy: no-referrer
Content-Length: 1564
Date: Sat, 18 Dec 2021 13:20:20 GMT


**********************************************************************

Если один или несколько ресурсов были созданы на исходном сервере в результате успешной
обработки запроса POST, исходный сервер ДОЛЖЕН отправить ответ 201 (Создан), содержащий
поле заголовка Location, которое предоставляет идентификатор для созданного первичного
ресурса (Раздел 7.1 .2) и представление, которое описывает состояние запроса при обращении к новому ресурсу (-ам).

10.2.2 201 Создан, Created.
Запрос был выполнен и в результате был создан новый ресурс. Новый созданный ресурс может быть вызван
по URI (одному или нескольким), возвращенным в объекте ответа; наиболее специфический
URL для ресурса отдается в поле заголовка Location. Первоначальный сервер ДОЛЖЕН создать
ресурс перед возвратом кода состояния 201. Если действие не может быть выполнено немедленно,
сервер должен возвратить ответ с кодом состояния 202 (Принято, Accepted) вместо 201.

10.2.3 202 Принято, Accepted.
Запрос был принят для обработки, но обработка не была завершена. В конечном счете запрос МОЖЕТ быть, а МОЖЕТ
и не быть выполнен, поскольку он МОЖЕТ быть отвергнут при фактической обработке. Не имеется никакой возможности
вторичной посылки кода состояния от асинхронной операции типа этой.

Ответ с кодом состояния 202 преднамеренно уклончив. Цель его состоит в том, чтобы позволить
ерверу принять запрос для некоторого другого процесса (возможно пакетно-ориентированного процесса,
который выполняется только один раз в день) и не требовать при этом, чтобы соединение агента пользователя
с сервером сохранялось до завершения процесса. Объекту, возвращенному с этим ответом СЛЕДУЕТ содержать
индикатор текущего состояния запроса и либо ссылку на монитор состояния, либо некоторую оценку времени,
когда пользователь может ожидать завершения выполнения запроса.



**********************************************************************/
#endif